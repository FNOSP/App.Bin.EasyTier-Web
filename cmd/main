#!/bin/bash

LOG_FILE="${TRIM_PKGVAR}/info.log"
PID_FILE="${TRIM_PKGVAR}/app.pid"
LOG_CHECK_MARKER="${TRIM_PKGVAR}/.log_check_marker"
LOG_MAX_SIZE=10485760  # 10MB = 10 * 1024 * 1024 bytes
LOG_CHECK_INTERVAL=3  # 检查间隔(天)

# 检查并清理日志文件大小（每3天检查一次）
check_log_size() {
    local should_check=false
    
    # 检查标记文件是否存在
    if [ ! -f "${LOG_CHECK_MARKER}" ]; then
        should_check=true
    else
        # 读取上次检查时间
        local last_check=$(cat "${LOG_CHECK_MARKER}" 2>/dev/null | tr -d '[:space:]')
        if [ -n "$last_check" ]; then
            # 计算天数差
            local current_time=$(date +%s)
            local days_diff=$(( (current_time - last_check) / 86400 ))
            if [ "$days_diff" -ge "$LOG_CHECK_INTERVAL" ]; then
                should_check=true
            fi
        else
            should_check=true
        fi
    fi
    
    if [ "$should_check" = true ]; then
        if [ -f "${LOG_FILE}" ]; then
            local file_size=$(stat -c%s "${LOG_FILE}" 2>/dev/null || stat -f%z "${LOG_FILE}" 2>/dev/null)
            if [ "${file_size}" -gt "${LOG_MAX_SIZE}" ]; then
                echo "$(date '+%Y-%m-%d %H:%M:%S') - Log file exceeded 10MB, clearing content" > "${LOG_FILE}"
            fi
        fi
        # 更新检查时间标记
        echo "$(date +%s)" > "${LOG_CHECK_MARKER}"
    fi
}


# 主函数
CONFIG_DIR="${TRIM_DATA_SHARE_PATHS%%:*}"

# 检查配置文件并初始化
check_and_init_config() {
    local config_file="${CONFIG_DIR}/config.json"
    
    # 确保CONFIG_DIR目录存在
    if [ ! -d "${CONFIG_DIR}" ]; then
        log_msg "Creating config directory: ${CONFIG_DIR}"
        mkdir -p "${CONFIG_DIR}"
    fi
    
    # 检查config.json文件是否存在
    if [ ! -f "${config_file}" ]; then
        log_msg "Config file not found, creating default config: ${config_file}"
        echo '{"uiport": "11211"}' > "${config_file}"
        log_msg "Default config created with uiport: 11211"
    else
        log_msg "Config file found: ${config_file}"
    fi
}

# 从config.json读取uiport
get_uiport() {
    local config_file="${CONFIG_DIR}/config.json"
    
    if [ ! -f "${config_file}" ]; then
        log_msg "Config file not found, using default port: 11211"
        echo "11211"
        return
    fi
    
    # 使用jq读取JSON，如果没有jq则使用简单的grep和sed
    if command -v jq >/dev/null 2>&1; then
        local port=$(jq -r '.uiport' "${config_file}" 2>/dev/null)
        if [ -n "${port}" ] && [ "${port}" != "null" ]; then
            echo "${port}"
        else
            echo "11211"
        fi
    else
        # 简单的JSON解析
        local port=$(grep -o '"uiport"[[:space:]]*:[[:space:]]*"[^"]*"' "${config_file}" | sed 's/.*"uiport"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/' | head -1)
        if [ -n "${port}" ]; then
            echo "${port}"
        else
            echo "11211"
        fi
    fi
}

# write the command to start your program here
# 将uiport值直接获取并设置，而不是在子shell中调用函数
UI_PORT=$(get_uiport)
CMD="${TRIM_APPDEST}/server/easytier-web-embed -a ${UI_PORT} -d ${TRIM_APPDEST}/server/data/et.db & sudo ${TRIM_APPDEST}/server/easytier-core -w udp://127.0.0.1:22020/admin"

log_msg() {
    # 先检查日志文件大小
    check_log_size
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> ${LOG_FILE}
}

kill_by_process_name() {
    local process_name=$1
    log_msg "Looking for process: $process_name"
    
    # 查找所有匹配的进程ID
    pids=$(pgrep -f "$process_name" 2>/dev/null)
    
    if [ -n "$pids" ]; then
        log_msg "Found $process_name processes: $pids"
        for pid in $pids; do
            if check_process "$pid"; then
                log_msg "Sending TERM signal to $process_name (PID: $pid)"
                kill -TERM "$pid" >> ${LOG_FILE} 2>&1
            fi
        done
        
        # 等待进程结束
        local count=0
        while [ $count -lt 5 ]; do
            remaining_pids=$(pgrep -f "$process_name" 2>/dev/null)
            if [ -z "$remaining_pids" ]; then
                break
            fi
            sleep 1
            count=$((count + 1))
            log_msg "Waiting for $process_name to terminate... (${count}s/5s)"
        done
        
        # 如果还有进程存活，强制杀死
        remaining_pids=$(pgrep -f "$process_name" 2>/dev/null)
        if [ -n "$remaining_pids" ]; then
            log_msg "Sending KILL signal to remaining $process_name processes: $remaining_pids"
            kill -KILL $remaining_pids 2>/dev/null
        fi
    else
        log_msg "No $process_name processes found"
    fi
}

start_process() {
    if status; then
        return 0
    fi

    # 在启动前检查并初始化配置文件
    check_and_init_config
    
    log_msg "Starting process ..."
    # run cmd to start process
    bash -c "${CMD}" >> ${LOG_FILE} 2>&1 &
    # write pid to pidfile
    printf "%s" "$!" > ${PID_FILE}
    # log_msg "CMD = ${CMD}"
    # log_msg "pid = $!"
    return 0
}

stop_process() {
    log_msg "Stopping process ..."

    # 首先通过进程名杀死特定进程（新增部分）
    kill_by_process_name "easytier-web-embed"
    kill_by_process_name "easytier-core"

    # 原有的通过PID文件停止进程的逻辑
    if [ -r "${PID_FILE}" ]; then
        pid=$(head -n 1 "${PID_FILE}" | tr -d '[:space:]')
        
        log_msg "pid=${pid}"
        if ! check_process "${pid}"; then
            # process not exist, delete pidfile
            rm -f "${PID_FILE}"
            log_msg "remove pid file 1"
            return
        fi

        log_msg "send TERM signal to PID:${pid}..."
        kill -TERM ${pid} >> ${LOG_FILE} 2>&1

        local count=0
        while check_process "${pid}" && [ $count -lt 10 ]; do
            sleep 1
            count=$((count + 1))
            log_msg "waiting process terminal... (${count}s/10s)"
        done

        if check_process "${pid}"; then
            log_msg "send KILL signal to PID:${pid}..."
            kill -KILL "${pid}"
            sleep 1
            rm -f "${PID_FILE}"
        else
            log_msg "process killed... "
        fi
    fi

    # 最后再次检查并清理可能的残留进程（新增部分）
    kill_by_process_name "easytier-web-embed"
    kill_by_process_name "easytier-core"

    return 0
}

check_process() {
    local pid=$1
    if kill -0 "${pid}" 2>/dev/null; then
        return 0  # process exist
    else
        return 1  # process not exist
    fi
}

status() {
    if [ -f "${PID_FILE}" ]; then
        pid=$(head -n 1 "${PID_FILE}" | tr -d '[:space:]')
        if check_process "${pid}"; then
            return 0
        else
            # Process is not running but pidfile exists - clean it up
            rm -f "${PID_FILE}"
        fi    
    fi

    return 1
}

case $1 in
start)
    # run start command. exit 0 if success, exit 1 if failed
    start_process
    ;;
stop)
    # run stop command. exit 0 if success, exit 1 if failed
    stop_process
    ;;
status)
    # check application status command. exit 0 if running, exit 3 if not running
    if status; then 
        exit 0
    else 
        exit 3
    fi
    ;;
*)
    exit 1
    ;;
esac
